{
  "query": "Which logic hands the lock to the next waiting owner after release?",
  "timestamp": "2025-12-25T03:48:40.088Z",
  "config": {
    "minLines": 10,
    "maxLines": 100,
    "topK": 5,
    "smartExpand": false
  },
  "source": "./context/js-context-retrieval/test3.file.js",
  "totalResults": 5,
  "results": [
    {
      "rank": 1,
      "start": 387,
      "end": 410,
      "originalStart": 387,
      "originalEnd": 410,
      "lines": 24,
      "score": 28012.28,
      "name": "releaselock",
      "type": "ClassMethod",
      "code": "  releaseLock(resourceId, ownerId) {\r\n    const lock = this.locks.get(resourceId);\r\n    if (!lock || lock.ownerId !== ownerId) {\r\n      return { released: false, reason: 'Not lock owner' };\r\n    }\r\n    \r\n    this.locks.delete(resourceId);\r\n    \r\n    // Process waiting queue\r\n    const waiting = this.waitingQueue.get(resourceId) || [];\r\n    if (waiting.length > 0) {\r\n      const next = waiting.shift();\r\n      clearTimeout(next.timeout);\r\n      this.locks.set(resourceId, {\r\n        ownerId: next.ownerId,\r\n        acquiredAt: Date.now(),\r\n        expiresAt: Date.now() + 5000\r\n      });\r\n      next.resolve({ acquired: true, resourceId });\r\n      this.waitingQueue.set(resourceId, waiting);\r\n    }\r\n    \r\n    return { released: true };\r\n  }\r"
    },
    {
      "rank": 2,
      "start": 350,
      "end": 371,
      "originalStart": 350,
      "originalEnd": 371,
      "lines": 22,
      "score": 17238.54,
      "name": "acquirelock",
      "type": "ClassMethod",
      "code": "  async acquireLock(resourceId, ownerId, timeoutMs = 5000) {\r\n    const existingLock = this.locks.get(resourceId);\r\n    \r\n    if (existingLock) {\r\n      // Check if lock expired\r\n      if (Date.now() > existingLock.expiresAt) {\r\n        this.locks.delete(resourceId);\r\n      } else if (existingLock.ownerId !== ownerId) {\r\n        // Wait for lock release\r\n        return this.waitForLock(resourceId, ownerId, timeoutMs);\r\n      }\r\n    }\r\n    \r\n    // Acquire the lock\r\n    this.locks.set(resourceId, {\r\n      ownerId,\r\n      acquiredAt: Date.now(),\r\n      expiresAt: Date.now() + timeoutMs\r\n    });\r\n    \r\n    return { acquired: true, resourceId };\r\n  }\r"
    },
    {
      "rank": 3,
      "start": 374,
      "end": 384,
      "originalStart": 374,
      "originalEnd": 384,
      "lines": 11,
      "score": 14172.13,
      "name": "waitforlock",
      "type": "ClassMethod",
      "code": "  waitForLock(resourceId, ownerId, timeoutMs) {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => {\r\n        reject(new Error('Lock acquisition timeout'));\r\n      }, timeoutMs);\r\n      \r\n      const waiting = this.waitingQueue.get(resourceId) || [];\r\n      waiting.push({ ownerId, resolve, reject, timeout });\r\n      this.waitingQueue.set(resourceId, waiting);\r\n    });\r\n  }\r"
    },
    {
      "rank": 4,
      "start": 525,
      "end": 580,
      "originalStart": 525,
      "originalEnd": 580,
      "lines": 56,
      "score": 11034.12,
      "name": "retryhandler",
      "type": "ClassDeclaration",
      "code": "class RetryHandler {\r\n  constructor(options = {}) {\r\n    this.maxRetries = options.maxRetries || 3;\r\n    this.baseDelay = options.baseDelay || 1000;\r\n    this.maxDelay = options.maxDelay || 30000;\r\n    this.backoffMultiplier = options.backoffMultiplier || 2;\r\n  }\r\n\r\n  // Calculate delay with exponential backoff and jitter\r\n  calculateDelay(attempt) {\r\n    const exponentialDelay = this.baseDelay * Math.pow(this.backoffMultiplier, attempt);\r\n    const cappedDelay = Math.min(exponentialDelay, this.maxDelay);\r\n    // Add jitter (Â±25%)\r\n    const jitter = cappedDelay * 0.25 * (Math.random() * 2 - 1);\r\n    return Math.round(cappedDelay + jitter);\r\n  }\r\n\r\n  // Execute with retry logic\r\n  async executeWithRetry(fn, context = {}) {\r\n    let lastError;\r\n    \r\n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\r\n      try {\r\n        return await fn();\r\n      } catch (error) {\r\n        lastError = error;\r\n        \r\n        if (attempt === this.maxRetries) break;\r\n        if (!this.shouldRetry(error)) break;\r\n        \r\n        const delay = this.calculateDelay(attempt);\r\n        console.log(`Retry ${attempt + 1}/${this.maxRetries} after ${delay}ms`);\r\n        await this.sleep(delay);\r\n      }\r\n    }\r\n    \r\n    throw lastError;\r\n  }\r\n\r\n  // Determine if error is retryable\r\n  shouldRetry(error) {\r\n    const retryableCodes = [408, 429, 500, 502, 503, 504];\r\n    if (error.statusCode && retryableCodes.includes(error.statusCode)) {\r\n      return true;\r\n    }\r\n    if (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT') {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Sleep helper\r\n  sleep(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n  }\r\n}\r"
    },
    {
      "rank": 5,
      "start": 412,
      "end": 422,
      "originalStart": 413,
      "originalEnd": 421,
      "lines": 11,
      "score": 5758.75,
      "name": "extendlock",
      "type": "ClassMethod",
      "code": "  // Extend lock duration\r\n  extendLock(resourceId, ownerId, extensionMs = 5000) {\r\n    const lock = this.locks.get(resourceId);\r\n    if (!lock || lock.ownerId !== ownerId) {\r\n      return { extended: false, reason: 'Not lock owner' };\r\n    }\r\n    \r\n    lock.expiresAt = Date.now() + extensionMs;\r\n    return { extended: true, newExpiry: lock.expiresAt };\r\n  }\r\n}\r"
    }
  ]
}